#!/usr/bin/env python3
"""
NanoMamba LUT Memory File Generator
====================================
Generates .mem initialization files for all LUTs used in NanoMamba RTL.

LUT tables:
  1. log_lut.mem     - log(x) in Q3.5 format (256 entries, INT8)
  2. exp_lut.mem     - exp(x) in Q8.0 format (256 entries, UINT8)
  3. sigmoid_lut.mem - sigmoid(x) in Q0.8 format (256 entries, UINT8)
  4. silu_lut.mem    - SiLU(x) = x*sigmoid(x) in Q1.7 format (256 entries, INT8)
  5. softplus_lut.mem - softplus(x) = log(1+exp(x)) (256 entries, UINT8)
  6. log2_lut.mem    - log2(x) scaled to INT8 (256 entries, UINT8)
  7. hann_window.mem - Hann window (256 entries, Q0.15 format, UINT16)
  8. twiddle_cos.mem - FFT twiddle factors cos (256 entries, Q1.14, INT16)
  9. twiddle_sin.mem - FFT twiddle factors sin (256 entries, Q1.14, INT16)
  10. recip_lut.mem  - 256/x reciprocal (128 entries, UINT8)

Output format: Verilog $readmemh compatible (hex values, one per line)

Author: Jin Ho Choi, Ph.D.
"""

import numpy as np
import os
import argparse


def gen_log_lut(n=256):
    """log(x+1) * 32, x in [0, 255], output Q3.5 signed INT8"""
    lut = np.zeros(n, dtype=np.int8)
    for x in range(n):
        val = np.log(x + 1) * 32.0
        lut[x] = np.clip(int(round(val)), -128, 127)
    return lut


def gen_exp_lut(n=256):
    """exp(x/32), x in [-128, 127] (stored as unsigned index 0-255), output Q8.0 UINT8"""
    lut = np.zeros(n, dtype=np.uint8)
    for i in range(n):
        x = i - 128  # Convert to signed
        val = np.exp(x / 32.0)
        lut[i] = np.clip(int(round(val)), 0, 255)
    return lut


def gen_sigmoid_lut(n=256):
    """sigmoid((x-128)/16) * 255, maps INT8 [-128,127] to [0,255]"""
    lut = np.zeros(n, dtype=np.uint8)
    for i in range(n):
        x = (i - 128) / 16.0  # Scale to reasonable sigmoid range
        val = 1.0 / (1.0 + np.exp(-x))
        lut[i] = np.clip(int(round(val * 255)), 0, 255)
    return lut


def gen_silu_lut(n=256):
    """SiLU(x) = x * sigmoid(x), input Q1.7 [-1.0, 0.992], output Q1.7 INT8"""
    lut = np.zeros(n, dtype=np.int8)
    for i in range(n):
        # Input as signed: -128 to 127 represents -1.0 to 0.992 in Q1.7
        x_int = i if i < 128 else i - 256
        x = x_int / 128.0
        val = x / (1.0 + np.exp(-x * 4.0))  # Scale sigmoid input for better range
        lut[i] = np.clip(int(round(val * 128)), -128, 127)
    return lut


def gen_softplus_lut(n=256):
    """softplus(x/16) * 16, input [-128,127] unsigned as 0-255, output UINT8"""
    lut = np.zeros(n, dtype=np.uint8)
    for i in range(n):
        x = (i - 128) / 16.0
        val = np.log(1.0 + np.exp(x)) * 16.0
        lut[i] = np.clip(int(round(val)), 0, 255)
    return lut


def gen_log2_lut(n=256):
    """8 * log2(x+1), x in [0, 255], output UINT8"""
    lut = np.zeros(n, dtype=np.uint8)
    lut[0] = 0
    for x in range(1, n):
        val = 8.0 * np.log2(x + 1)
        lut[x] = np.clip(int(round(val)), 0, 255)
    return lut


def gen_hann_window(n=256):
    """Hann window: 0.5 * (1 - cos(2*pi*k/N)) in Q0.15 format (UINT16)
    Only first half stored (symmetric)"""
    lut = np.zeros(n, dtype=np.uint16)
    N = n * 2  # Full window is 512 points, store 256
    for k in range(n):
        val = 0.5 * (1.0 - np.cos(2.0 * np.pi * k / N))
        lut[k] = np.clip(int(round(val * 32768)), 0, 65535)
    return lut


def gen_twiddle_cos(n=256):
    """FFT twiddle factors: cos(2*pi*k/N) in Q1.14 format (INT16)
    N=512, k=0..255"""
    lut = np.zeros(n, dtype=np.int16)
    N = 512
    for k in range(n):
        val = np.cos(2.0 * np.pi * k / N)
        lut[k] = np.clip(int(round(val * 16384)), -32768, 32767)
    return lut


def gen_twiddle_sin(n=256):
    """FFT twiddle factors: sin(2*pi*k/N) in Q1.14 format (INT16)
    N=512, k=0..255"""
    lut = np.zeros(n, dtype=np.int16)
    N = 512
    for k in range(n):
        val = np.sin(2.0 * np.pi * k / N)
        lut[k] = np.clip(int(round(val * 16384)), -32768, 32767)
    return lut


def gen_recip_lut(n=128):
    """Reciprocal: 256/x for x=0..127, output UINT8
    Used for GAP normalization in classifier"""
    lut = np.zeros(n, dtype=np.uint8)
    lut[0] = 255  # Avoid div by zero
    for x in range(1, n):
        val = 256.0 / x
        lut[x] = np.clip(int(round(val)), 0, 255)
    return lut


def write_mem_hex8(filename, data, comment=""):
    """Write LUT as hex file (one byte per line, Verilog $readmemh format)"""
    with open(filename, 'w') as f:
        f.write(f"// {comment}\n")
        f.write(f"// {len(data)} entries, hex format\n")
        f.write(f"// Generated by gen_lut_mem.py for NanoMamba RTL\n")
        f.write(f"// Author: Jin Ho Choi, Ph.D.\n\n")
        for i, val in enumerate(data):
            v = int(val)  # Convert numpy scalar to Python int
            if data.dtype in (np.int8, np.int16):
                # Signed: convert to unsigned representation for hex
                if data.dtype == np.int8:
                    f.write(f"{v & 0xFF:02X}\n")
                else:
                    f.write(f"{v & 0xFFFF:04X}\n")
            elif data.dtype == np.uint16:
                f.write(f"{v:04X}\n")
            else:
                f.write(f"{v & 0xFF:02X}\n")


def main():
    parser = argparse.ArgumentParser(description='Generate NanoMamba LUT memory files')
    parser.add_argument('--output', '-o', default='../rtl/mem/',
                        help='Output directory for .mem files')
    args = parser.parse_args()

    os.makedirs(args.output, exist_ok=True)

    print("=" * 60)
    print("  NanoMamba LUT Memory File Generator")
    print("  Author: Jin Ho Choi, Ph.D.")
    print("=" * 60)

    # Generate all LUTs
    luts = {
        'log_lut': (gen_log_lut, 256, 'log(x+1)*32, Q3.5 INT8'),
        'exp_lut': (gen_exp_lut, 256, 'exp((x-128)/32), Q8.0 UINT8'),
        'sigmoid_lut': (gen_sigmoid_lut, 256, 'sigmoid((x-128)/16)*255, Q0.8 UINT8'),
        'silu_lut': (gen_silu_lut, 256, 'SiLU(x/128)*128, Q1.7 INT8'),
        'softplus_lut': (gen_softplus_lut, 256, 'softplus((x-128)/16)*16, UINT8'),
        'log2_lut': (gen_log2_lut, 256, '8*log2(x+1), UINT8'),
        'hann_window': (gen_hann_window, 256, 'Hann window Q0.15 (half, N=512)'),
        'twiddle_cos': (gen_twiddle_cos, 256, 'cos(2*pi*k/512), Q1.14 INT16'),
        'twiddle_sin': (gen_twiddle_sin, 256, 'sin(2*pi*k/512), Q1.14 INT16'),
        'recip_lut': (gen_recip_lut, 128, '256/x, UINT8 (for GAP division)'),
    }

    total_bytes = 0
    for name, (gen_fn, size, comment) in luts.items():
        data = gen_fn(size)
        filepath = os.path.join(args.output, f'{name}.mem')
        write_mem_hex8(filepath, data, comment)
        nbytes = len(data) * data.itemsize
        total_bytes += nbytes
        print(f"  {name + '.mem':<20s}  {size:>4d} entries  ({nbytes:>5d} bytes)  {comment}")

    print(f"\n  Total LUT storage: {total_bytes} bytes ({total_bytes/1024:.1f} KB)")
    print(f"  Output directory: {os.path.abspath(args.output)}")
    print("=" * 60)

    # Print verification summary
    print("\nVerification (first 8 entries):")
    for name, (gen_fn, size, _) in luts.items():
        data = gen_fn(min(size, 16))
        vals = ', '.join([f'{v}' for v in data[:8]])
        print(f"  {name}: [{vals}, ...]")


if __name__ == '__main__':
    main()
